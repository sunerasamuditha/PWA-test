/* eslint-disable no-restricted-globals */
// Custom Service Worker with Push Notification Support
// This file is injected with Workbox precache manifest

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// Precache all assets generated by Vite build
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches
cleanupOutdatedCaches();

// Runtime caching strategies

// 1. Auth endpoints - NetworkOnly (no caching) - applies to ALL methods
registerRoute(
  ({ url }) => url.pathname.match(/\/api\/auth\//),
  new NetworkOnly()
);

// 2. API requests - NetworkFirst with short expiration
registerRoute(
  ({ url }) => url.pathname.match(/\/api\//),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 5 // 5 minutes
      })
    ]
  })
);

// 3. Static resources (JS/CSS) - StaleWhileRevalidate
registerRoute(
  ({ url }) => url.pathname.match(/\.(?:js|css)$/),
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      })
    ]
  })
);

// 4. Images - CacheFirst with limits
registerRoute(
  ({ url }) => url.pathname.match(/\.(?:png|jpg|jpeg|svg|gif|webp|ico)$/),
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30 // 30 days
      })
    ]
  })
);

// 5. Google Fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new CacheFirst({
    cacheName: 'google-fonts-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
      })
    ]
  })
);

registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'gstatic-fonts-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
      })
    ]
  })
);

// Background Sync for failed API mutations
const bgSyncPlugin = new BackgroundSyncPlugin('api-queue', {
  maxRetentionTime: 60 * 24 // Retry for up to 24 hours (in minutes)
});

// Register background sync for API POST/PUT/PATCH/DELETE
registerRoute(
  ({ url, request }) => 
    url.pathname.match(/\/api\//) && 
    ['POST', 'PUT', 'PATCH', 'DELETE'].includes(request.method),
  new NetworkOnly({
    plugins: [bgSyncPlugin]
  }),
  'POST'
);

registerRoute(
  ({ url, request }) => 
    url.pathname.match(/\/api\//) && 
    request.method === 'PUT',
  new NetworkOnly({
    plugins: [bgSyncPlugin]
  }),
  'PUT'
);

registerRoute(
  ({ url, request }) => 
    url.pathname.match(/\/api\//) && 
    request.method === 'PATCH',
  new NetworkOnly({
    plugins: [bgSyncPlugin]
  }),
  'PATCH'
);

registerRoute(
  ({ url, request }) => 
    url.pathname.match(/\/api\//) && 
    request.method === 'DELETE',
  new NetworkOnly({
    plugins: [bgSyncPlugin]
  }),
  'DELETE'
);

// Push Notification Event Handler
self.addEventListener('push', (event) => {
  console.log('Push notification received:', event);

  let notificationData = {
    title: 'WeCare Notification',
    body: 'You have a new notification',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-192x192.png',
    vibrate: [200, 100, 200],
    data: {
      url: '/'
    }
  };

  // Parse notification payload
  if (event.data) {
    try {
      const payload = event.data.json();
      notificationData = {
        title: payload.title || notificationData.title,
        body: payload.body || payload.message || notificationData.body,
        icon: payload.icon || notificationData.icon,
        badge: payload.badge || notificationData.badge,
        vibrate: payload.vibrate || notificationData.vibrate,
        data: {
          url: payload.url || payload.data?.url || notificationData.data.url,
          ...payload.data
        },
        tag: payload.tag,
        requireInteraction: payload.requireInteraction || false,
        actions: payload.actions || []
      };
    } catch (error) {
      console.error('Error parsing push notification:', error);
    }
  }

  // Show notification
  const promiseChain = self.registration.showNotification(
    notificationData.title,
    notificationData
  );

  event.waitUntil(promiseChain);
});

// Notification Click Event Handler
self.addEventListener('notificationclick', (event) => {
  console.log('Notification clicked:', event);

  event.notification.close();

  // Get the URL to open from notification data
  const urlToOpen = event.notification.data?.url || '/';

  // Handle action buttons
  if (event.action) {
    console.log('Notification action clicked:', event.action);
    // You can handle specific actions here
  }

  // Open or focus the app window
  const promiseChain = clients.matchAll({
    type: 'window',
    includeUncontrolled: true
  }).then((clientList) => {
    // Check if there's already a window open with this URL
    for (let i = 0; i < clientList.length; i++) {
      const client = clientList[i];
      if (client.url === urlToOpen && 'focus' in client) {
        return client.focus();
      }
    }
    
    // If no window is open, open a new one
    if (clients.openWindow) {
      return clients.openWindow(urlToOpen);
    }
  });

  event.waitUntil(promiseChain);
});

// Skip waiting and claim clients
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

self.addEventListener('activate', (event) => {
  event.waitUntil(clients.claim());
});

console.log('WeCare Service Worker loaded with push notification support');
